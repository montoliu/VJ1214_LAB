\chapterimage{chapter_head_1.pdf} 
\chapter{El modo teselado}

Este capítulo explica el funcionamiento del modo teselado. La lista de ejercicios y el tiempo estimado (en minutos) para su realización se muestran en la Tabla \ref{c7_tab:ejercios}.

\begin{table}[t]
	\centering
	\caption{Ejercicios del capítulo y tiempo estimado para su realización.}
	\begin{tabular}{|c|c|}
		\hline 
		Ejercicio & Tiempo \\ 
		\hline 
		7.1 & 0' \\ 
		7.2 & 0' \\ 
		7.3 & 0' \\ 
		7.4 & 0' \\ 
		7.5 & 0' \\ 
		7.6 & 0' \\ 
		7.7 & 0' \\ 
		7.8 & 0' \\ 
		\hline 
	\end{tabular} 
	\label{c7_tab:ejercios}
\end{table}



% -----------------------------------------------------
% -----------------------------------------------------
% -----------------------------------------------------
% -----------------------------------------------------
\section{El modo teselado}
El modo teselado permite muchas más posibilidades a la hora de realizar videjuegos con gráficos que el modo framebuffer. 

\subsection{Funcionamiento básico del modo teselado}
En el modo teselado, la pantalla se divide en celdas conocidas como teselas. Una tesela es un bitmap de 8x8 que representa un gráfico que se quiere mostrar en una de las celdas en las que se divide la pantalla. 

Para definir una tesela, se deberá declarar un vector de 64 elementos ($8*8=64$) del tipo \textit{u8}. 

\begin{example}
Por ejemplo, el siguiente código define las figuras del comecocos, del fantasma y un fondo:

\begin{lstlisting}
u8 comecocos[64] =
{
	2,2,1,1,1,1,2,2,
	2,2,1,1,1,1,1,2,
	2,2,2,1,1,1,1,1,
	2,2,2,2,1,1,1,1,
	2,2,2,2,1,1,1,1,
	2,2,2,1,1,1,1,1,
	2,2,1,1,1,1,1,2,
	2,2,1,1,1,1,2,2,
};

u8 fantasma[64] =
{
	2,2,2,3,3,2,2,2,
	2,3,3,3,3,3,3,2,
	3,3,3,3,3,3,3,3,
	3,4,2,3,3,4,2,3,
	3,4,2,3,3,4,2,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,2,3,2,2,3,2,3
};

u8 fondo[64] =
{
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2
};
\end{lstlisting}
\end{example}

Como se puede comprobar, se han definido los píxeles que componen la figura que representa la tesela. Se pueden definir hasta 1024 teselas diferentes. Existen dos formas de especificar los colores de los píxeles de las teselas:

\begin{itemize}
\item Modo de 256 colores: A cada píxel se le asigna un índice de la paleta de colores. El índice por lo tanto será un entero de 8 bits, con un valor comprendido entre 0 y 255. Este es el modo que se usará en esta sección. Por ejemplo, en las teselas anteriores, el número 1 indica el color almacenado en la posición 1 de la paleta de colores, el número 2 se refiere a la segunda posición, etc. 
%
\item Modo de 16 colores: En este caso un píxel es un índice a una paleta de 16 colores. Por lo tanto el índice será un entero de 4 bits, con un valor comprendido entre 0 y 15. Aunque este modo requiere menos memoria, dejando así más espacio para teselas y otros elementos en la VRAM, la calidad de la imagen renderizada se puede ver comprometida al disponer de solo 16 colores diferentes en cada tesela.
\end{itemize}

Para especificar los colores (en el modo de 256 colores), se debe modificar (en el programa principal) la paleta de colores mediante la variable \textit{BG\_PALETTE}. 

\begin{example}
Por ejemplo, el código siguiente define los cuatro colores usados en las definiciones de las teselas anteriores:

\begin{lstlisting}
	BG_PALETTE[1]=RGB15(28,0,0);
	BG_PALETTE[2]=RGB15(0,20,0);
	BG_PALETTE[3]=RGB15(0,0,31);
	BG_PALETTE[4]=RGB15(31,31,31);
\end{lstlisting}
\end{example}
	
Como se puede comprobar, la posición 1 de la paleta se refiere a un color rojo, la 2 a uno verde, la 3 a uno azul y la 4 al color blanco.

En este modo de funcionamiento, el número de colores está limitado a 256 (de 0 a 255), número que se puede representar usando un byte. Por lo tanto, una tesela ocupa en memoria $8*8*1=64$ bytes. 

Para definir cómo se muestran las teselas en la pantalla se puede declarar un vector que tendrá tantos elementos como teselas queramos mostrar. Por ejemplo, si queremos mostrar toda la pantalla, será necesario declarar el vector con 768 elementos del tipo u16 ($32*24=768$). En dicho vector, comúnmente llamado mapa de teselas, se especifica la tesela a mostrar usando un número entero (de 2 bytes). El identificador de la tesela es el orden en el que estará almacenada en la memoria. 

\begin{example}
El siguiente código declara el mapa de teselas para que cubra toda la pantalla (24 filas y 32 columnas):

\begin{lstlisting}
u16 mapData[768] =
{
1,2,3,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,

2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,

2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,

2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,

2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,

2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2
};
\end{lstlisting}
\end{example}
	
Como se puede comprobar, el elemento que se situará en la fila 0, columna 0 es la tesela con identificador 1 que será la que se almacenará en la memoria en primer lugar (será el comecocos), y la que se situará a su derecha es la tesela con identificador 2, que será la que se almacenará en segundo lugar (será el fondo). La tesela almacenada en la tercera posición (será el fantasma) se mostrará en la fila 0, columna 2. Las teselas que se muestran en cada posición se podrán modificar durante el transcurso del programa.

El mapa de teselas ocupará, en este caso, $768*2=1\ 536$ bytes. Este vector se copiará en la memoria del fondo para que el motor gráfico sepa qué teselas tiene que mostrar en la pantalla.

Una de las principales ventajas de este modo es el ahorro en el uso de memoria que proporciona esta forma de trabajar. Esto es debido a que el mapa de teselas especifica donde está almacenada la tesela a mostrar, no el contenido de la misma. Es decir, en vez de guardar $24*32*64 = 49\ 152$ bytes (24 filas, 32 columnas y cada tesela de $8\times8$ píxeles de 1 byte), se almacena $24*32*2 = 1\ 536$ bytes (24 filas, 32 columnas y 2 bytes por cada identificador de la tesela) más 64 bytes por cada tesela usada. Como en el ejemplo anterior se usaban tres teselas, el tamaño total de memoria que se necesita es $1\ 536 + 64*3 = 1\ 728$ bytes, lo que supone un ahorro de más del 95\% de memoria.

Con respecto al modo framebuffer el ahorro de memoria es incluso mayor. En el modo framebuffer especificamos el color de cada uno de los 192x256 píxeles usando un número de 2 bytes. Por lo tanto, se necesitan $192*256*2=98\ 302$ bytes. 

Para configurar el modo teselado, deberemos usar las siguientes instrucciones:

\begin{lstlisting}
	REG_POWERCNT = POWER_ALL_2D;
	REG_DISPCNT  = MODE_0_2D    | DISPLAY_BG0_ACTIVE ;
	VRAM_A_CR    = VRAM_ENABLE  | VRAM_A_MAIN_BG ;
	BGCTRL [0]   = BG_32x32     | BG_COLOR_256 | BG_MAP_BASE(0) | BG_TILE_BASE(1);
\end{lstlisting}

La línea 1 activa ambos motores gráficos. En la segunda línea indicamos que vamos a usar el modo 0 y el fondo 0 del motor principal (ver Figura \ref{fig_c5_modulos}). En la tercera línea activamos el banco de memoria \textit{VRAM\_A} y lo asignamos como memoria de fondos del motor principal. 

La cuarta línea se utiliza para configurar la memoria de fondos del fondo 0:
\begin{itemize}
	\item Con \textit{BG\_32\_32} elegimos el número de teselas máximo que podemos usar. Hay cuatro posibilidades $32\times32$, $32\times64$, $64\times32$ y $64\times64$. En nuestro caso se ha seleccionado $32\times32$.
	%
	\item Con \textit{BG\_COLOR\_256} indicamos que las teselas tendrán 256 colores que se especificarán en la paleta.
	%
	\item Con \textit{ BG\_MAP\_BASE(0)} indicamos donde se va a guardar el mapa de teselas. En este caso el mapa de teselas se almacenará en el primer bloque (para mapas) de la \textit{VRAM\_A}.
	%
	\item Por último, con \textit{BG\_TILE\_BASE(1)} indicamos donde se almacenarán las teselas, que en este caso es a partir del segundo bloque (para teselas) de la \textit{VRAM\_A}.
\end{itemize}
  

La memoria \textit{VRAM\_A} tiene un tamaño de 128KB (ver Tabla \ref{tab_c5_vram}). Tanto la memoria de teselas como las teselas se deben copiar a este banco de memoria. Los mapas de teselas se almacenan en bloques de 2KB. Hay 32 posibles posiciones (de la 0 a la 31). En este ejemplo, el mapa de teselas se almacenará en el primer bloque mediante la macro \textit{BG\_MAP\_BASE(0)}. Como el mapa de teselas ocupa $24*32*2 = 1\ 536$ bytes, cabe perfectamente en un único bloque de 2KB. Si no cupiera, se deberían usar más bloques.

Las teselas se guardan en bloques de 16KB. Hay 16 posibles posiciones (de la 0 a la 15). En este ejemplo, las tres teselas se almacenarán en el segundo bloque mediante la macro \textit{BG\_TILE\_BASE(1)}. Como las tres teselas ocupan $8*8*1*3 = 192$ bytes, cabe perfectamente en un único bloque de 16KB. Si no cupiera, se deberían usar más bloques. 

Hay que tener en cuenta que la zona usada para almacenar el mapa de tesela no se puede solapar con la zona usada para almacenar las teselas. Por eso las teselas empiezan en el bloque 1, puesto que parte de la memoria del bloque 0 ya está ocupada por el mapa de teselas.

Una vez configurado el modo teselado, hemos de copiar a memoria tanto el mapa de teselas como las propias teselas. El código siguiente muestra este proceso:

\begin{lstlisting}
	static u8*  tileMemory = (u8*)  BG_TILE_RAM(1);
	static u16* mapMemory  = (u16*) BG_MAP_RAM(0);

	// Copia de teselas
	dmaCopy(comecocos,tileMemory + 64,  sizeof(comecocos));
	dmaCopy(fondo,    tileMemory + 128, sizeof(fondo));
	dmaCopy(fantasma, tileMemory + 192, sizeof(fantasma));

	// Copia del mapa de teselas a la memoria gráfica
	pos_mapData = 0;
	for(i=0;i<32;i++)
		for(j=0;j<24;j++)
		{
			pos_mapMemory            = i*24+j;
			mapMemory[pos_mapMemory] = mapData[pos_mapData];
			pos_mapData ++;
		}
\end{lstlisting}

En las dos primeras líneas creamos dos variables para acceder a la zona de la memoria en VRAM\_A donde estará almacenado el mapa de teselas y a la zona de memoria (también en VRAM\_A) donde estarán almacenadas las teselas. Es importante destacar que ambas variables se refieren a posiciones de memoria dentro de la \textit{VRAM\_A}, aunque cada una apunta a una zona diferente dentro de esta memoria.

En las líneas 5, 6 y 7 se copian las teselas a la zona de memoria que le corresponde, empezando por \textit{tileMemory + 64} para la primera tesela. En este caso, la primera tesela es el comecocos, seguida del fondo y por último el fantasma. Por lo tanto, en el mapa de teselas pondremos 1 cuando queramos mostrar el comecocos, 2 para el fondo y 3 para el fantasma. Es importante destacar que las teselas se han empezado a almacenar a partir de la posición base + 64, puesto que la primera tesela que usamos tiene como índice 1 (y no 0). El desplazamiento es de 64 bytes puesto que cada tesela, en el modo de 256 colores, ocupa $8\times8$ píxeles de un byte, es decir 64 bytes. Si se especificara las teselas en el modo de 16 colores, el desplazamiento sería de 32 bytes, ya que en este caso la tesela ocupa $8\times8$ píxeles de un medio byte (4 bits).

En las líneas 11 a 17 se copia el mapa de teselas a la memoria gráfica.

A continuación se muestra el código completo del programa que muestra como resultado el gráfico que se muestra en la Figura \ref{fig_p2_c3_comecocos}

\begin{lstlisting}
#include <nds.h>
#include <stdio.h>

u8 comecocos[64] =
{
	2,2,1,1,1,1,2,2,
	2,1,1,1,1,1,2,2,
	1,1,1,1,1,2,2,2,
	1,1,1,1,2,2,2,2,
	1,1,1,1,2,2,2,2,
	1,1,1,1,1,2,2,2,
	2,1,1,1,1,1,2,2,
	2,2,1,1,1,1,2,2,
};

u8 fondo[64] =
{
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2,
	2,2,2,2,2,2,2,2
};

u8 fantasma[64] =
{
	2,2,2,3,3,2,2,2,
	2,3,3,3,3,3,3,2,
	3,3,3,3,3,3,3,3,
	3,4,2,3,3,4,2,3,
	3,4,2,3,3,4,2,3,
	3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,
	3,2,3,2,2,3,2,3
};

// Mapa de teselas 32x24 = 768
u16 mapData[768] =
{
1,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,3,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,3,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,

2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,

2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,

2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,

2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,

2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2
};

int main(void)
{
	int i,j,pos_mapMemory,pos_mapData;

	REG_POWERCNT = POWER_ALL_2D;
	REG_DISPCNT  = MODE_0_2D   | DISPLAY_BG0_ACTIVE ;
	VRAM_A_CR    = VRAM_ENABLE | VRAM_A_MAIN_BG ;
	BGCTRL[0]    = BG_32x32    | BG_COLOR_256 | BG_MAP_BASE(0) | BG_TILE_BASE(1);

	BG_PALETTE[1]=RGB15(28,0,0);
	BG_PALETTE[2]=RGB15(0,20,0);
	BG_PALETTE[3]=RGB15(0,0,31);
	BG_PALETTE[4]=RGB15(31,31,31);

	static u8*  tileMemory = (u8*)  BG_TILE_RAM(1);
	static u16*  mapMemory = (u16*) BG_MAP_RAM(0);

	dmaCopy(comecocos, tileMemory + 64,  sizeof(comecocos));
	dmaCopy(fondo,     tileMemory + 128, sizeof(fondo));
	dmaCopy(fantasma,  tileMemory + 192, sizeof(fantasma));

	pos_mapData = 0;
	for(i=0;i<32;i++)
		for(j=0;j<24;j++)
		{
			pos_mapMemory            = i*24+j;
			mapMemory[pos_mapMemory] = mapData[pos_mapData];
			pos_mapData ++;
		}

	while(1)
	{
		swiWaitForVBlank();
	}
}
\end{lstlisting}

\begin{figure}[t]
	\centering
	\includegraphics[height=9cm]{Figuras/P2_C3/p2_c3_comecocos.jpg}
	\caption{Salida del programa de esta sección en la NDS}
	\label{fig_p2_c3_comecocos}
\end{figure}

Si queremos que la pantalla se modifique como respuesta a un evento, únicamente tenemos que cambiar la memoria de teselas (mapMemory) correspondiente a la posición que queremos cambiar, modificando el índice a la tesela que queremos mostrar.

Por ejemplo, el siguiente fragmento de código mostrará al pulsar la tecla A de la NDS, un segundo comecocos en la celda situada en la fila 15 y columna 16:

\begin{lstlisting}
while(1)
{
	scanKeys();
	int key = keysDown();

	if (key & KEY_A)
	{
		i                        = 15;
		j                        = 16;
		pos_mapMemory            = i*24+j;
		mapMemory[pos_mapMemory] = 1;
	}
	swiWaitForVBlank();
}
\end{lstlisting}

\subsection{Funcionamiento avanzado del modo teselado}
El motor gráfico renderiza los fondos teselados a partir de las entradas del \textit{mapa} y la \textit{colección de teselas} a las que hace referencia, estando estos datos contenidos en la memoria de fondos de la VRAM. Teniendo en cuenta que cada motor gráfico puede gestionar un máximo de cuatro fondos, es necesario que cada fondo activado configure la localización de sus datos de mapas y teselas. Para ello se utiliza el registro de configuración del fondo, \textit{REG\_BGnCNT} o \textit{BGCTRL[n]}, donde \textit{n} hace referencia al índice del fondo, tomando valores de 0 a 3. Este registro reserva 4 bits para especificar el desplazamiento de las teselas (en múltiplos de 16 KB) y 5 bits para el mapa (en múltiplos de 2 KB), de tal forma que las teselas admiten $2^4 = 16$ posibles valores del desplazamiento base y los mapas admiten $2^5 = 32$. La Figura \ref{fig_p2_c3_reg_teselado} muestra el significado de cada uno de sus bits.

\begin{figure}[t]
\centering
\includegraphics[height=4cm]{Figuras/P2_C3/p2_c3_reg_teselado.PNG}
\caption{Significados de los bits del registro \textit{REG\_BGnCNT}.}
\label{fig_p2_c3_reg_teselado}
\end{figure}

% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
\subsubsection{Guardar mapas de teselas en la VRAM}
Un \textit{mapa de teselas} puede empezar en cualquier dirección múltiplo de 2KB entre 0 x 2KB y 31 x 2KB. Estos valores expresados en hexadecimal serían desde 0 x 0x800 hasta 31 x 0x800. Para que se facilite la configuración de las direcciones base, \textit{libnds} incluye la macro \textit{BG\_MAP\_BASE(n)}, donde \textit{n} se corresponde con el múltiplo de \textit{2KB} seleccionado, entre 0 y 31. Por ejemplo, si se indica en el registro de configuración del fondo que los datos del mapa se encuentran ubicados a partir de \textit{BG\_MAP\_BASE(1)}, significa que comenzarán en la posición de memoria \textit{0x0800} a partir del principio de la memoria de fondos. Análogamente, decir que lo hacen en \textit{BG\_MAP\_BASE(31)} significa que empiezan en la posición \textit{\textit{0xf800}}, tal y como se puede comprobar en la figura \ref{fig_p2_c3_teselas3}.

\begin{figure}[t]
\centering
\includegraphics[height=14cm]{Figuras/P2_C3/p2_c3_teselas3.PNG}
\caption{Desplazamientos en la VRAM.}
\label{fig_p2_c3_teselas3}
\end{figure}

El motor de vídeo no tiene memoria física dedicada, por tanto, \textit{parte de la memoria VRAM se debe configurar para ser utilizada como memoria de fondos}. El motor gráfico principal utiliza como memoria de fondos el rango de memoria de \textit{0x06000000} a \textit{0x0607ffff} (512KB máximo) mientras que el secundario emplea el rango de \textit{0x06200000} a \textit{0x0621ffff} (128KB máximo). Todos los desplazamientos base de mapas y teselas se llevan a cabo tomando como dirección base el comienzo de estos rangos de memoria.

El tamaño de un mapa de teselas depende del tamaño del fondo:
\begin{itemize}
\item  Un mapa de 32x32 teselas será una sucesión de 32x32 entradas de 16 bits (aspecto que se explicará con más detalle a continuación), por lo que el tamaño total será de 2x32x32 = 2KB. Es decir, en este caso el mapa entero cabe antes de la siguiente dirección base de otro mapa.
%
\item  Sin embargo, para un fondo de 64x64 teselas, los datos del mapa requieren 2x64x64 = 8KB, es decir, las siguientes 3 posibles direcciones base no estarían disponibles para otro mapa.
\end{itemize}

Estos cálculos se muestran de manera gráfica en la Figura \ref{fig_p2_c3_teselas2b}.

\begin{figure}[t]
\centering
\includegraphics[height=4cm]{Figuras/P2_C3/p2_c3_teselas2b.PNG}
\caption{Cálculo del tamaño de un mapa de teselas.}
\label{fig_p2_c3_teselas2b}
\end{figure}

Como se ha comentado previamente cada una de las entradas del mapa se representa mediante un conjunto de 16 bits, donde los 10 bits menos significativos especifican la tesela, razón por la que el conjunto máximo de teselas es de  1024, las máximas referenciables con 10 bits. Los dos bits siguientes se utilizan para especificar el efecto de espejo en la tesela, es decir, si tiene una reflexión horizontal, vertical o ambas. Finalmente, para teselas que utilizan paletas de 16 colores, se utilizan los 4 últimos bits para identificar la paleta de colores utilizada por esa tesela. La Figura \ref{fig_p2_c3_entmapateselas} muestra dicha distribución.

\begin{figure}[t]
\centering
\includegraphics[height=1cm]{Figuras/P2_C3/p2_c3_bitsteselas.PNG}
\caption{Entradas del mapa de teselas.}
\label{fig_p2_c3_entmapateselas}
\end{figure}

\subsubsection{Guardar teselas en la VRAM}
En cuanto a las teselas, ocurre lo mismo que para los mapas, ya que ambos comparten la misma memoria de fondos y al igual que los mapas, utilizarán los desplazamientos para gestionar esa memoria como si estuviera organizada en bloques, sólo que en este caso, de \textit{tamaño 16KB}. La macro utilizada para especificar la dirección base es \textit{BG\_TILE\_BASE(n)}, donde \textit{n} toma valores entre 0 y 15. El número hace referencia al múltiplo de 16KB correspondiente, empezando en 0x0000, desplazándose en múltiplos de 0x4000 hasta el valor 0x3c000, tal y como se puede observar en la figura \ref{fig_p2_c3_teselas3}. 










%Este capítulo explica como funciona el sistema de memoria gráfica de la consola Nintendo DS. Se comienza describiendo la \textit{memoria de vídeo (VRAM)}, se continúa con los conceptos de \textit{fondo} y \textit{sprite}, y se finaliza haciendo hincapié en dos tipos de configuración de los fondos: \textit{framebuffer} y \textit{teselado}.
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\section{Introducción}
%La Nintendo DS tiene dos pantallas gráficas de tipo LCD (\textit{Liquid Crystal Display}). Las dos tienen el mismo tamaño, 256x192 píxeles, y funcionan gracias a dos motores gráficos intercambiables, uno principal o \textit{main} y otro secundario o \textit{sub}, diferenciados únicamente en que el motor principal puede renderizar tanto la memoria de vídeo virtual sin utilizar el motor 2D, como mapas de bits de 256 colores, así como utilizar el motor 3D para el renderizado de alguno de sus fondos. 
%
%Las imágenes deben ser traducidas a contenido binario, que es el que se guardará junto con el programa y que debe ser copiado en el \textit{banco de memoria VRAM (Video RAM)} en el que está mapeada la pantalla, para que se pueda mostrar en ella. Mapear la pantalla a un banco de memoria significa que a la pantalla se le asigna ese banco de memoria, de forma que lo que se haya escrito en ese banco de
%memoria será lo que se vea en la pantalla. 
%
%Las imágenes que se pueden mostrar en pantalla pueden ser al menos de dos tipos: \textit{fondos} y \textit{sprites}. Los \textit{fondo}s, aunque se pueden desplazar, rotar, transformar y redimensionar, tienen menos capacidad de movimiento que los \textit{sprites}, que pueden ser animaciones que se mueven por toda la pantalla. 
%
%La Nintendo DS tiene 9 bancos de memoria de vídeo, que se pueden usar con diferentes propósitos. Cada de uno de estos bancos de memoria está etiquetado desde \textit{VRAM\_A} hasta \textit{VRAM\_I}, tal y como se muestra en la Figura \ref{fig_p2_c3_bancos_memoria}.
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=9cm]{Figuras/P2_C3/p2_c3_vram1.PNG}
%\caption{Bancos de memoria de la NDS}
%\label{fig_p2_c3_bancos_memoria}
%\end{figure}
%
%La Tabla \ref{tab_p2_c3_NivelesDeEjecución} muestra cada uno de los bancos de memoria VRAM con su tamaño y su dirección de memoria. Por tanto, la cantidad total de memoria de vídeo es de 656KB. 
%
%\begin{table}[t]
%	\centering
%	\caption{Tamaño y dirección de memoria de cada banco de memoria.}
%		\begin{tabular}{|l |c | c|}
%      \hline
%Banco & Tamaño &  Dirección memoria  \\
%\hline
%\hline
%VRAM\_A & 128KB & 0x6800000 \\
%\hline
%VRAM\_B & 128KB  &	0x6820000 \\
%\hline
%VRAM\_C & 128KB  &	0x6840000 \\
%\hline
%VRAM\_D	& 128KB  &	0x6860000 \\
%\hline
%VRAM\_E	& 64KB  &	0x6880000\\
%\hline
%VRAM\_F 	& 16KB  &	0x6890000 \\
%\hline
%VRAM\_G 	& 16KB  &	0x6894000\\
%\hline
%VRAM\_H	& 32KB & 	0x6898000 \\
%\hline
%VRAM\_I	& 16KB  &	0x68a0000\\
%\hline
%		\end{tabular}
%\label{tab_p2_c3_NivelesDeEjecución}
%\end{table}
%
%\subsection{El registro \textit{REG\_POWERCNT}} 
%
%El registro \textit{REG\_POWERCNT} es el encargado del encendido de todo el hardware gráfico. La Figura \ref{tab_p2_c3_bits_reg_powercnt} muestra el significado de algunos de sus bits:
%
%\begin{figure}[h]
%\centering
%\includegraphics[height=6cm]{Figuras/P2_C3/p2_c3_reg_powercnt.PNG}
%\caption{Significado de los bits del registro \textit{REG\_POWERCNT}}
%\label{tab_p2_c3_bits_reg_powercnt}
%\end{figure}
%
%El contenido de este registro permite activar ambas pantallas y los dos motores gráficos: el principal (main) y el secundario (sub) para trabajar en 2D. Además, el bit 15  permite intercambiar ambas pantallas y asignar  el motor principal a la pantalla superior (top) en vez de a la inferior que es la que tiene por defecto.
%
%Si no se inicializa dicho registro, tiene asignado por defecto el valor  0x0203, es decir $0000\ 0010\ 0000\ 0011_2$ en binario, o dicho de otra forma, todos los bits a cero salvo el 0 (\textit{POWER\_LCD}), el 1 (\textit{POWER\_2D\_A}) y el 9 (\textit{POWER\_2D\_B}). Esto quiere decir que activa  ambas pantallas, activa los dos motores para trabajar en 2D y no está activo el bit 15, de forma que el motor principal (main) está asignado a la pantalla inferior (bottom).
%
%Para activar determinados bits de dicho registro se puede usar la instrucción:
%\begin{verbatim}
%REG_POWERCNT = POWER_LCD | POWER_2D_A;
%\end{verbatim}
%
%En la instrucción anterior se activan ambas pantallas y el motor principal.
%
%\subsection{Los modos gráficos}
%
%El concepto de fondo es básico para comprender cómo funcionan los modos de vídeo de la Nintendo DS y se puede entender como un concepto equivalente al de capa o \textit{layer} utilizado por algunas aplicaciones de diseño gráfico para facilitar la composición de una imagen a partir de la superposición del contenido de las capas. Los núcleos gráficos de la Nintendo DS disponen de cuatro fondos, etiquetados como \textit{BG0}, \textit{BG1}, \textit{BG2} y \textit{BG3}, cuya configuración dependerá del tipo de gráfico a representar.
%
%Un modo gráfico básicamente agrupa un conjunto de configuraciones para cada uno de los fondos. La Figura \ref{fig_p2_c3_modulos} resume los modos disponibles para el motor principal y el secundario. Los seis primeros modos, \textit{Mode 0} a \textit{Mode 5}, son comunes para los dos motores. Además, el motor principal cuenta con el \textit{Mode 6} y con el modo \textit{framebuffer}.
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=9cm]{Figuras/P2_C3/p2_c3_modos-graficos.PNG}
%\caption{Modulos gráficos}
%\label{fig_p2_c3_modulos}
%\end{figure}
%
%En la Figura \ref{fig_p2_c3_modulos} se pueden ver tres tipos diferentes de configuraciones para los fondos 2D, que son:
%\begin{itemize}
%	\item \textit{Text}: modos \textit{Teselados} (o texturas).
%	\item \textit{Rotation} y \textit{Extended Rotation}: modos \textit{Rotoscale}.
%	\item \textit{Framebuffer}: dibuja la imagen directamente sin utilizar fondos.
%\end{itemize}
%
%%A continuación se presentan diferentes forma de controlar los modos y fondos, así de cómo activar los bancos de memoria \textit{VRAM}.
%
%El registro \textit{REG\_DISPCNT} es el que se encarga de controlar los modos y fondos activos. La Figura \ref{fig_p2_c3_reg_dispcnt3} muestra el significado de algunos de sus
%bits:
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=4cm]{Figuras/P2_C3/p2_c3_reg_dispcnt3.png}
%\caption{Significado de los bits del registro \textit{REG\_DISPCNT}}
%\label{fig_p2_c3_reg_dispcnt3}
%\end{figure}
%
%Cabe destacar la finalidad de los siguientes bits:
%\begin{itemize}
%	\item Bits 0-2: especifican el modo gráfico. Del 0 al 6 en binario con tres bits.
%	\item Bits 8-12: especifican el fondo.
%	\item Bits 17-19: especifican la configuración del modo gráfico \textit{framebuffer}.
%\end{itemize}
%
%Por ejemplo, para indicar que se activa el \textit{Modo 0} con el fondo \textit{BG0} se realiza
%\begin{verbatim}
%REG_DISPCNT = MODE_0_2D | DISPLAY_BG0_ACTIVE;
%\end{verbatim}
%Esta operación también se puede llevar a cabo mediante
%\begin{verbatim}
%videoSetMode(MODE_0_2D);
%\end{verbatim}
%
%Cada \textit{banco VRAM} tiene un registro \textit{VRAM\_?\_CR}(? puede tomar los valores de A a I) para activarlo y seleccionar su función. La Figura \ref{fig_p2_c3_reg_vram1} muestra el significado de cada uno de sus bits. Cabe destacar que los bits etiquetados con \textit{Modo} y \textit{Desplazamiento} son los que permiten seleccionar la función del fondo configurado en el registro \textit{REG\_DISPCNT}. Por su parte el \textit{bit 7} es el que permite activar el correspondiente \textit{banco VRAM}.
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=4cm]{Figuras/P2_C3/p2_c3_reg_vram1.PNG}
%\caption{Significado de los bits del registro \textit{VRAM\_X\_CR}}
%\label{fig_p2_c3_reg_vram1}
%\end{figure}
%
%Como ejemplo, para indicar que se activa \textit{VRAM\_A} y que se asigna a fondos del motor principal (\textit{main}) se hace
%\begin{verbatim}
%VRAM_A_CR = VRAM_A_ENABLE | VRAM_A_MAIN_BG;
%\end{verbatim}
%Esta operación también se podría llevar a cabo mediante
%\begin{verbatim}
%vramSetBankA(VRAM_A_MAIN_BG);
%\end{verbatim}
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\section{Modo Framebuffer}
%La principal peculiaridad de este modo de representación es que la pantalla se mapea directamente a la memoria sin utilizar el motor de renderizado, de forma que lo que se escribe en memoria es lo que se muestra. La pantalla se compone de 49152 píxeles, organizados en 192 líneas de 256 píxeles cada una, donde a su vez, el contenido de cada píxel representa un color en formato \textit{RGB (Red Green Blue)} de 16 bits.
%
%El modo framebuffer admite cuatro tipos de configuración, que reciben el nombre de \textit{FB0}, \textit{FB1}, \textit{FB2} o \textit{FB3} y que básicamente se corresponden con los bancos VRAM de 128KB cuyo contenido se va a volcar en la pantalla. Esta relación se muestra en la Figura \ref{fig_p2_C3_framebuffer}.
%
%\newpage
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=2cm]{Figuras/P2_C3/p2_c3_framebuffer.PNG}
%\caption{El modo framebuffer}
%\label{fig_p2_C3_framebuffer}
%\end{figure}
%
%Antes de poder cargar los datos en memoria habrá que especificar el modo seleccionado, para lo cual se utiliza el registro \textit{REG\_DISPCNT} empleando:
%\begin{verbatim}
%REG_DISPCNT = MODE_FB0;
%\end{verbatim}
%En este caso, al especificar el modo de vídeo, indirectamente se está especificando la zona de memoria donde se deberán escribir los datos que se van a mostrar en la pantalla. En base a la línea anterior, que selecciona el modo \textit{FB0}, el motor gráfico trabajará con los datos del banco de memoria \textit{VRAM\_A}. Esta operación también se puede realizar mediante:
%\begin{verbatim}
%videoSetMode(MODE_FB0);
%\end{verbatim}
%Sin embargo, para poder utilizar los bancos de memoria es necesario que éstos estén habilitados y configurados según su finalidad.  La siguiente línea de código muestra que el \textit{banco VRAM\_A} mapea directamente su contenido a la pantalla:
%\begin{verbatim}
%VRAM_A_CR = VRAM_A_ENABLE | VRAM_A_LCD;
%\end{verbatim}
%Esta operación también se podría llevar a cabo mediante:	
%\begin{verbatim}
%vramSetBankA(VRAM_A_LCD);
%\end{verbatim}
%Una vez especificado el modo y habilitada la zona de memoria donde se escribirán los datos, el siguiente paso consiste en escribir en la memoria el valor que se asignará a cada uno de los píxeles de la pantalla, bien mediante una asignación manual, utilizando la macro \textit{RGB15} o escribiendo los datos correspon\-dien\-tes a una imagen específica. A continuación se describen ambas operaciones.
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsection{Dibujando píxeles en el modo framebuffer}
%Una de las formas de  representar gráficos en el modo framebuffer consiste en crear una imagen a partir de la asignación de colores a cada uno de los píxeles que componen
%la pantalla. El primer paso consistirá en especificar el modo de vídeo utilizado, tal y como se ha comentado previamente, mediante:
%\begin{verbatim}
%REG_DISPCNT = MODE_FB0;
%VRAM_A_CR = VRAM_ENABLE | VRAM_A_LCD;
%\end{verbatim}
%A continuación habrá que utilizar un bucle que recorra la región de memoria correspondiente para escribir uno por uno el valor del color que se desea asignar a cada uno de los píxeles que componen la pantalla. La macro \textit{RGB15} permite obtener ese valor, indicando la cantidad de color rojo, verde y azul de la que se compone el color que se pintará en cada píxel.
%
%El siguiente código (\textit{frame\_pixels.c}) colorea inicialmente la pantalla de rojo. Después, según el botón pulsado se cambiará el color de la misma, así, si se pulsa el botón \textit{A} se pondrá de color verde, mientras que si se pulsa el botón \textit{X} lo hará de color azul:
%\begin{verbatim}
%#include <nds.h>
%#include <stdio.h>
%
%int main(void)
%{
%  int lin,col;
%
%  consoleDemoInit();
%  REG_DISPCNT = MODE_FB0;
%  //videoSetMode(MODE_FB0);
%  VRAM_A_CR = VRAM_ENABLE | VRAM_A_LCD;
%  //vramSetBankA(VRAM_A_LCD);
%
%  u16 color = RGB15(31,0,0);  //rojo
%
%  while(1) {
%    scanKeys();
%    int held = keysHeld();
%
%    if (held & KEY_A) color = RGB15(0,31,0);  //verde
%    if (held & KEY_X) color = RGB15(0,0,31);  //azul
%
%    swiWaitForVBlank();
%    // Rellena la memoria de video con el color elegido
%    // Ancho = 256; Alto = 192
%    for(lin=0;lin<192;lin++)
%      for(col=0;col<256;col++)
%        VRAM_A[lin*256+col]=color;
%   }
%  return 0;
%}
%\end{verbatim}
%
%En el bucle \textit{for} se emplea \textit{VRAM\_A}, que se corresponde con la dirección de comienzo de la memoria del framebuffer \textit{FB0}, para acceder al píxel co\-rres\-pondiente a la línea \textit{lin} y a la columna \textit{col}. Dado que los píxeles se almacenan por líneas y cada línea tiene 256 píxeles, se tendrá que multiplicar el número de línea por 256 para ir al comienzo de la fila y sumar el número de columna para llegar al píxel corres\-pon\-dien\-te de la pantalla. La asignación del color a cada píxel consiste en obtener el valor del color en formato \textit{RGB15} y asignarlo a la posición de memoria del píxel correspondiente.\\
%
%En el programa presentado se podrían haber sustituido los dos bucles por uno solo:
%\begin{verbatim}
%for(i=0;i<256*192;i++) VRAM_A[i]=color;
%\end{verbatim}
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsection{Transferencia de datos mediante DMA}
%La transferencia de datos juega un papel esencial en la representación gráfica, no sólo en el modo framebuffer. A lo largo de este apartado se describirán las funciones más comunes de la librería \textit{libnds} que dan soporte al \textit{acceso directo a memoria} \textit{(DMA: Direct Memory Access)}, así como otros tipos de transferencia de datos usando la CPU.
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsubsection{Funciones para la transferencia de datos}
%La librería \textit{libnds} proporciona una serie de funciones que soportan el proceso de transferencia de datos utilizando controladores de DMA. Estas funciones están
%declaradas en el archivo de cabecera \textit{dma.h}, donde se puede encontrar, por ejemplo, la definición de la función \textit{dmaCopy} utilizada en el código \textit{frame\_imagen.c}:
%\begin{verbatim}	
%dmaCopy(wallpaperBitmap,VRAM_A,256*192*2);
%\end{verbatim}
%El primer argumento de esta función se corresponde con la dirección de memoria donde se encuentran los datos a transferir. En este caso \textit{wallpaperBitmap}, que se encuentra declarado en el fichero \textit{wallpaper.h}. El segundo argumento indica la dirección de memoria donde se van a transferir, en este caso se copian los 256x192 píxeles de la imagen en \textit{VRAM\_A}. Finalmente, el tercer argumento indica el tamaño de esos datos en bytes, que también aparece en \textit{wallpaper.h} como \textit{wallpaperBitmapLen}.  En este caso hay que recordar que cada píxel ocupa 2 bytes.
%
%Siempre que sea posible será preferible utilizar funciones de transferencia sobre DMA, ya que al no intervenir la CPU, el proceso es más rápido y eficiente. Pero hay situaciones en las que no es posible emplear  funciones de transferencia sobre DMA, lo que obliga a utilizar funciones de transferencia que utilicen la CPU. Estas situaciones son:
%
%\begin{itemize}
%\item La memoria \textit{DTCM (Data Tightly Coupled Memory)} es un tipo de memoria de datos muy rápida, de 16 KB de tamaño, que se encuentra dentro del procesador ARM9. La consola Nintendo DS ubica la pila en ese tipo de memoria. Como la memoria DTCM  no está conectada al bus accesible por el controlador de DMA, éste no tiene acceso a la misma, y por tanto se deben utilizar funciones de transferencia que utilicen la CPU cuando se desea transferir datos desde la pila.
%%
%\item  La función \textit{dmaCopy} tampoco permite la transferencia de un bloque de datos de tamaño superior a 128KB, de ahí que si se quisiera cargar en memoria una imagen
%de 512x512, con un tamaño 256KB (512x512x2), también se tendría que recurrir a una función de transferencia que utilice la CPU o hacer dos transferencia de 128KB cada una, utilizando DMA.
%\end{itemize}
%
%Como alternativas a la función de transferencia sobre DMA se tienen:
%\begin{itemize}
%\item La función \textit{memcpy}, que como primer argumento recibe la dirección de memoria donde se transferirán los datos, como segundo argumento la dirección de memoria donde se encuentran los datos a transferir y finalmente el tamaño de los datos a transferir. La misma operación anterior de transferencia sería:
%\begin{verbatim}	
%memcpy(VRAM_A,wallpaperBitmap,256*192*2);
%\end{verbatim}
%%
%\item Otra opción para la transferencia de datos es hacer uso de la función \textit{swiCopy}, una rutina de la BIOS que soporta la transferencia en bloques de 2 bytes. La definición
%de esta función establece como primer argumento la dirección de memoria de la localización de los datos a transferir, como segundo argumento la dirección de memoria
%donde se transferirán los datos y finalmente el tamaño de los mismos, en cantidad de 2 bytes. La misma operación anterior de transferencia sería:
%\begin{verbatim}	
%swiCopy(wallpaperBitmap,VRAM_A,256*192);
%\end{verbatim}
%\end{itemize}
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\section{Modo Teselado}
%El último paso en la escala creciente de funcionalidad de los gráficos se corresponde con los fondos \textit{teselados}. Un fondo teselado se compone de dos partes:
%\begin{itemize}
%	\item \textit{Colección de} \textit{teselas} (\textit{tile set}): conjunto de hasta 1024 teselas diferentes (de 0 a 1023), donde cada una viene identificada según la posición que ocupa dentro de la colección de teselas.
%	\item \textit{Mapa de teselas}: matriz de tamaño \{32 ó 64\}x\{32 ó 64\} (dependiendo del tamaño del fondo), que especifica qué tesela se colocará en cada uno de los huecos que componen esa matriz imaginaria de teselas en la que se ha dividido el fondo.
%\end{itemize}
%
%En el contexto de los fondos teselados el gráfico se va a describir en función de tres elementos básicos:
%\begin{itemize}
%	\item La \textit{tesela}, de tamaño 8x8 píxeles, es la unidad mínima de composición de los fondos teselados.
%	\item Toda tesela puede admitir una de entre tres \textit{transformaciones}: espejo con respecto al eje \textit{Y}, con respecto al eje \textit{X} o a ambos.
%	\item La \textit{paleta de colores}: Existe un modo especial de gráficos teselados que divide la paleta de colores en 16 paletas de 16 colores. Sólo para este caso, en cada componente del mapa se tendrá que especificar la paleta utilizada, de entre las 16 disponibles.
%\end{itemize}
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsection{Elementos básicos de los fondos teselados}
%En relación a la gestión de memoria, la principal novedad que  presentan los fondos \textit{teselados} con respecto al modo \textit{framebuffer} es que ahora el motor 2D espera encontrar los datos relativos a los gráficos en una zona de memoria específica, denominada \textit{memoria de fondos} (\textit{background memory}). El motor 2D, por defecto no tiene más memoria asignada que la de \textit{sprites} y la de \textit{paletas}, por tanto surge la necesidad de mapear bancos de memoria VRAM, a aquellas
%zonas donde el motor espera encontrar los datos a dibujar.\\
%
%Antes de pasar a estudiar de manera más detallada los fundamentos de los fondos teselados, se van a describir los elementos básicos de dichos fondos mediante la  Figura \ref{fig_p2_c3_fondos_teselados}. Como se puede observar, parte de la memoria VRAM se puede configurar para albergar la memoria de fondos, y dentro de ésta los datos de mapas y teselas que compondrán los fondos teselados. Simplificando al máximo los fundamentos de la representación de gráficos teselados, el mapa de un fondo teselado se compone de referencias a teselas y, cuando se utilicen paletas de 16 colores, también de referencias a la subpaleta utilizada para cada tesela.
%Por otro lado, en la zona de la memoria de fondos destinada a albergar los datos de las teselas, cada entrada se corresponderá con una tesela. Cada píxel se representa mediante el índice del color correspondiente en la paleta de colores mediante 8 bits por píxel, o en un modo más compacto que solo utiliza 4 bits por píxel al usar paletas de 16 colores.
%Finalmente, el último eslabón de esta cadena es la paleta o paletas de colores, que ya se ha descrito previamente. Como novedad, la paleta de 256 colores se puede utilizar como un grupo de 16 paletas de 16 colores.
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=6cm]{Figuras/P2_C3/p2_c3_teselas1.PNG}
%\caption{Elementos básicos de los fondos teselados.}
%\label{fig_p2_c3_fondos_teselados}
%\end{figure}
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsection{Fondos teselados}
%En cualquiera de los modos disponibles para los dos motores gráficos (el principal y el secundario), hay al menos uno de los fondos configurado para trabajar como
%fondo teselado. Por ejemplo, el \textit{modo 5} elegido para la representación de fondos \textit{extended rotoscale} se puede utilizar también para representar fondos teselados,
%utilizando en este caso los fondos 0 ó 1. La configuración de los fondos teselados debe incluir tres elementos:
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=5cm]{Figuras/P2_C3/p2_c3_paleta.PNG}
%\caption{Ejemplo de palera.}
%\label{fig_p2_c3_paleta}
%\end{figure}
%
%\begin{itemize}
%\item Desplazamiento en la VRAM: especifica dónde se ubicarán los datos, tanto
%del mapa como de las teselas que compondrán el fondo. Se estudiará con más detalle
%en la siguiente sección.
%%
%\item Tamaño: especificado en teselas de entre un conjunto limitado de posibles tamaños. Hay que recordar que cada tesela
%tiene 8x8 píxeles, y que, el tamaño del fondo está limitado a una de las posibles combinaciones de \{32 ó 64\}x\{32 ó 64\} teselas.
%%
%\item Tipo de paleta: hay dos modos de colores para las teselas:
%	\begin{itemize}
%		\item Modo de 256 colores: A cada píxel se le asigna un índice de la paleta de colores. El índice por lo tanto será un entero de 8 bits, con un valor comprendido entre 0 y
%255. La  Figura \ref{fig_p2_c3_paleta} muestra un ejemplo de paleta en la que el número 0 se corresponde con el color negro, el número 1 con el color rojo, etc. 
%		\item Modo de 16 colores: En este caso un píxel es un índice a una paleta de 16 colores. Por lo tanto el índice será un entero de 4 bits, con un valor comprendido entre 0 y
%15. Aunque este modo requiere menos memoria, dejando así más espacio para teselas y otros elementos en la VRAM, la calidad de la imagen renderizada se puede ver comprometida al disponer de solo 16 colores diferentes en cada tesela.
%\end{itemize}
%\end{itemize}
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsection{Desplazamientos en la VRAM}
%El motor gráfico renderiza los fondos teselados a partir de las entradas del \textit{mapa} y la \textit{colección de teselas} a las que hace referencia, estando estos datos contenidos en la memoria de fondos de la VRAM. Teniendo en cuenta que cada motor gráfico puede gestionar un máximo de cuatro fondos, es necesario que cada fondo activado configure
%la localización de sus datos de mapas y teselas. Para ello se utiliza el registro de configuración del fondo, \textit{REG\_BGnCNT} o \textit{BGCTRL[n]}, donde \textit{n} hace
%referencia al índice del fondo, tomando valores de 0 a 3. Este registro reserva 4 bits para especificar el desplazamiento de las teselas (en múltiplos de 16 KB) y 5 bits para el
%mapa (en múltiplos de 2 KB), de tal forma que las teselas admiten $2^4 = 16$ posibles valores del desplazamiento base y los mapas admiten $2^5 = 32$. La Figura \ref{fig_p2_c3_reg_teselado} muestra el significado de cada uno de sus bits.
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=4cm]{Figuras/P2_C3/p2_c3_reg_teselado.PNG}
%\caption{Significados de los bits del registro \textit{REG\_BGnCNT}.}
%\label{fig_p2_c3_reg_teselado}
%\end{figure}
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsubsection{Guardar mapas de teselas en la VRAM}
%Un \textit{mapa de teselas} puede empezar en cualquier dirección múltiplo de 2KB entre 0 x 2KB y 31 x 2KB. Estos valores expresados en hexadecimal serían desde 0 x 0x800 hasta 31 x 0x800. Para que se facilite la configuración de las direcciones base, \textit{libnds} incluye la macro \textit{BG\_MAP\_BASE(n)}, donde \textit{n} se corresponde con el múltiplo de \textit{2KB} seleccionado, entre 0 y 31. Por ejemplo, si se indica en el registro de configuración del fondo que los datos del mapa se encuentran ubicados a partir de \textit{BG\_MAP\_BASE(1)}, significa que comenzarán en la posición de memoria \textit{0x0800} a partir del principio de la memoria de fondos. Análogamente, decir
%que lo hacen en \textit{BG\_MAP\_BASE(31)} significa que empiezan en la posición \textit{\textit{0xf800}}, tal y como se puede comprobar en la figura \ref{fig_p2_c3_teselas3}.\\
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=14cm]{Figuras/P2_C3/p2_c3_teselas3.PNG}
%\caption{Desplazamientos en la VRAM.}
%\label{fig_p2_c3_teselas3}
%\end{figure}
%
%El motor de vídeo no tiene memoria física dedicada, por tanto, \textit{parte de la memoria VRAM se debe configurar para ser utilizada como memoria de fondos}. El motor gráfico principal utiliza como memoria de fondos el rango de memoria de \textit{0x06000000} a \textit{0x0607ffff} (512KB máximo) mientras que el secundario emplea el rango de \textit{0x06200000} a \textit{0x0621ffff} (128KB máximo). Todos los desplazamientos base de mapas y teselas se llevan a cabo tomando como dirección base el comienzo de estos rangos de memoria.
%
%El tamaño de un mapa de teselas depende del tamaño del fondo:
%\begin{itemize}
%\item  Un mapa de 32x32 teselas será una sucesión de 32x32 entradas de 16 bits (aspecto que se explicará con más detalle a continuación), por lo que el tamaño total será de 2x32x32 = 2KB. Es decir, en este caso el mapa entero cabe antes de la siguiente dirección base de otro mapa.
%%
%\item  Sin embargo, para un fondo de 64x64 teselas, los datos del mapa requieren 2x64x64 = 8KB, es decir, las siguientes 3 posibles direcciones base no estarían disponibles para otro mapa.
%\end{itemize}
%
%Estos cálculos se muestran de manera gráfica en la Figura \ref{fig_p2_c3_teselas2b}.
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=4cm]{Figuras/P2_C3/p2_c3_teselas2b.PNG}
%\caption{Cálculo del tamaño de un mapa de teselas.}
%\label{fig_p2_c3_teselas2b}
%\end{figure}
%
%Como se ha comentado previamente cada una de las entradas del mapa se representa mediante un conjunto de 16 bits, donde los 10 bits menos significativos especifican la tesela, razón por la que el conjunto máximo de teselas es de  1024, las máximas referenciables con 10 bits. Los dos bits siguientes se utilizan para especificar el efecto de espejo en la tesela, es decir, si tiene una reflexión horizontal, vertical o ambas. Finalmente, para teselas que utilizan paletas de 16 colores, se utilizan los 4 últimos bits para identificar la paleta de colores utilizada por esa tesela. La Figura \ref{fig_p2_c3_entmapateselas} muestra dicha distribución.
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=1cm]{Figuras/P2_C3/p2_c3_bitsteselas.PNG}
%\caption{Entradas del mapa de teselas.}
%\label{fig_p2_c3_entmapateselas}
%\end{figure}
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsubsection{Guardar teselas en la VRAM}
%En cuanto a las teselas, ocurre lo mismo que para los mapas, ya que ambos comparten la misma memoria de fondos y al igual que los mapas, utilizarán los desplazamientos
%para gestionar esa memoria como si estuviera organizada en bloques, sólo que en este caso, de \textit{tamaño 16KB}. La macro utilizada para especificar la dirección base es
%\textit{BG\_TILE\_BASE(n)}, donde \textit{n} toma valores entre 0 y 15. El número hace referencia al múltiplo de 16KB correspondiente, empezando en 0x0000, desplazándose en
%múltiplos de 0x4000 hasta el valor 0x3c000, tal y como se puede observar en la figura \ref{fig_p2_c3_teselas2b}. 
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsubsection{Tamaño de un píxel}
%Una cuestión importante es la de determinar el tamaño de un píxel. La NDS soporta dos modos de color para las teselas de un fondo teselado, el modo de 256 colores utiliza 8 bits para identificar un color de la paleta, de tal forma que cada píxel tendrá un tamaño de 1 byte. En cambio si se usan 16 paletas de 16 colores cada una, el índice de paleta podrá especificarse con sólo 4 bits, lo que supone un ahorro de memoria VRAM, aunque también supone al mismo tiempo una pérdida en cuanto al número de colores disponibles. Teniendo en cuenta que el desplazamiento en la memoria de fondos para las teselas es múltiplo de 16KB, se puede obtener el número de teselas que almacena cada bloque lógico para cada uno de los dos modos de colores de las teselas:
%\begin{itemize}
%	\item \textit{256 teselas en modo de 256 colores}: 256 teselas x 64 píxeles/tesela x 1 byte/píxel = 16KB.
%		\item \textit{512 en modo de 16 colores}: 512 teselas x 64 píxeles/tesela x 1/2 byte/píxel = 16KB.
%\end{itemize}
%
%Hay que tener mucho cuidado a la hora de utilizar los desplazamientos en la memoria de fondos, ya que ésta es la misma para mapas y teselas, lo que significa
%que una incorrecta utilización de esos desplazamientos puede lleva a escribir unos datos sobre otros. Como ejemplo de esto, se presentan dos posibles configuraciones:
%\begin{verbatim}
%1 BGCTRL[0] = BG_32x32 | BG_COLOR_16 | BG_MAP_BASE(0) | BG_TILE_BASE(1);
%2 BGCTRL[0] = BG_32x32 | BG_COLOR_16 | BG_MAP_BASE(0) | BG_TILE_BASE(0);
%\end{verbatim}
%En ambas se emplea un mapa de 32x32 teselas con el modo de 16 colores. Utilizando la figura \ref{fig_p2_c3_teselas2b} se puede comprobar que la primera configuración es correcta, puesto que especifica que los datos del mapa están contenidos a partir de la dirección 0x0000 mientras que los datos de la tesela se encuentran a partir de la dirección 0x04000 (\textit{el múltiplo 1 de 16KB}). En este caso no existe superposición de los datos. Sin embargo, la segunda configuración es incorrecta, ya que los datos del mapa y los de las teselas están configurados a partir de la misma dirección.
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsection{Teselas}
%Los gráficos teselados vienen descritos mediante una matriz de teselas, donde cada \textit{tesela} representa un pequeño mapa de bits de 8x8 píxeles, donde  dependiendo del tipo del modo de color utilizado (16 ó 256 colores) se compondrá de entradas de 4 u 8 bits. Para entender mejor el concepto de gráfico teselado, se puede imaginar la pantalla de la consola dividida en celdas de dimensiones 8x8 píxeles, donde cada cuadrado se corresponde con una tesela, quedando la pantalla dividida en 32 teselas de ancho y 24 de largo.
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsubsection{Definición de teselas empleando paletas de 16 colores}
%La  Figura \ref{fig_p2_c3_teselas4} presenta la definición de una tesela utilizando un vector \textit{unsigned char} que representa la forma de la letra \textit{A}, junto con la imagen representada en la tesela.
%
%%\newpage
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=4.5cm]{Figuras/P2_C3/p2_c3_teselas4.PNG}
%\caption{Definición de una tesela que representa la letra \textit{A}.}
%\label{fig_p2_c3_teselas4}
%\end{figure}
%
%En este caso se define una tesela que utiliza una paleta de 16 colores. Como se puede comprobar, cada elemento del vector de tipo \textit{unsigned char} (de 8 bits de tamaño) especifica el color de dos píxeles, dedicando los \textit{4 bits} correspondientes a cada uno de los dígitos de la notación hexadecimal utilizada a expresar el índice de la paleta para cada píxel. Debido al orden de bytes (\textit{endianness}) de la máquina, los bits menos significativos ocupan las posiciones más bajas, de tal forma, que por ejemplo, el valor 0x10, para los dos primeros píxeles de la tesela, asignan al píxel 0 (el menos significativo) el índice 0 de la paleta y el píxel 1 (el más significativo) el índice 1 de la paleta. 
%
%Sin embargo, la forma más cómoda de definir teselas que utilizan paletas de 16 colores es utilizar un vector de tipo \textit{unsigned long}, ya que como tal, cada elemento de este vector tiene un tamaño de 32 bits, de tal forma que adoptando una notación hexadecimal de 8 dígitos, cada uno de ellos se corresponde con la especificación del color de los píxeles de la tesela. La Figura \ref{fig_p2_c3_teselas6} presenta la declaración de otra tesela  utilizando un vector de \textit{unsigned long} que representa una flecha, junto con la imagen representada en la tesela:
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=4.5cm]{Figuras/P2_C3/p2_c3_teselas6.PNG}
%\caption{Definición de una tesela que representa una flecha.}
%\label{fig_p2_c3_teselas6}
%\end{figure}
%
%Debido a la simetría de la imagen representada en la primera tesela no se aprecia el \textit{endianness} utilizado, sin embargo, en la definición de la segunda tesela sí que se aprecia.
%
%Una de las principales ventajas derivadas del uso de paletas de 16 colores es que simplemente cambiando de paleta cambia el color de la tesela. Por ejemplo, para el
%mismo código la misma tesela que representa la flecha, suponiendo ahora que se cambia la paleta y que el color que ocupa la posición 1 es el color negro, la tesela asignará el color negro a los píxeles que apunten a la posición 1. Si se vuelve a cambiar de paleta, ahora por una paleta cuya elemento de índice 1 sea el color azul, la tesela también cambiará de aspecto, dibujando en azul los píxeles que contengan el índice 1.
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsubsection{Definición de teselas empleando una paleta de 256 colores}
%Cuando se utiliza una paleta de 256 colores se necesitan 8 bits ($2^8 = 256$) por píxel. De tal forma, que la misma tesela para representar la \textit{letra A}, utilizando en este caso 8 bits por píxel se puede definir mediante un vector de \textit{unsigned char}, quedando de la siguiente manera que muestra la Figura \ref{fig_p2_c3_teselas5}.
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=4.5cm]{Figuras/P2_C3/p2_c3_teselas5.PNG}
%\caption{Definición de una tesela para la letra \textit{A}.}
%\label{fig_p2_c3_teselas5}
%\end{figure}
%
%%%\newpage
%
%El uso de una notación decimal, en lugar de la hexadecimal, es más cómoda, pues cada píxel se corres\-ponde con un elemento del vector de 64 elementos que describen los píxeles de la tesela.
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsubsection{Definición de paletas de colores para fondos}
%En resumen, la paleta de colores para fondos tiene 256 colores, que se puede definir de dos formas posibles:
%\begin{itemize}
%	\item Una paleta de 256 colores, donde cada color toma los valores de \textit{0x00} a \textit{0x0f}.
%	\item 16 paletas de 16 colores, donde cada paleta toma los valores de \textit{0x0} a \textit{0xf} y cada color de \textit{0x0} a \textit{0xf}.
%\end{itemize}
%La memoria donde se guardan las paletas comienza en la dirección de memoria \textit{0x05000000}. Para simplificar la gestión de las paletas, \textit{libnds} utiliza la macro 
%\textit{BG\_PALETTE[n]}. Así,  \textit{BG\_PALETTE[0x36]} puede hacer referencia:
%\begin{itemize}
%	\item al color \textit{0x36} de la paleta de 256 colores, o
%	\item al color 6 de la paleta 3 de 16 colores.
%\end{itemize}
%
%
%
%La Figura \ref{fig_p2_c3_teselas7b}  muestra una tesela en la que se emplea una paleta de 16 colores:
%
%\begin{figure}[t]
%\centering
%\includegraphics[height=5cm]{Figuras/P2_C3/p2_c3_teselas7b.PNG}
%\caption{Definición de una tesela que usa una paleta de 16 colores.}
%\label{fig_p2_c3_teselas7b}
%\end{figure}
%
%Se puede observar que en la declaración de la tesela, el valor 1 se corresponde con la entrada 1 de la paleta (en este caso \textit{RGB(31,0,0)}), el valor 2 con la entrada 2
%(en este caso \textit{RGB(31,15,0)}), y así sucesivamente. La tesela definida se caracteriza porque toda la columna tiene el mismo color.  También se puede observar el efecto del \textit{endianness}.
%
%
%% ------------------------------------------------------------------------
%% ------------------------------------------------------------------------
%\subsubsection{Copiando las teselas en memoria}
%La configuración especificada para el fondo teselado será determinante para obtener la dirección de memoria donde se escribirán los datos del mismo. Los índices empleados
%en la configuración en las macros \textit{BG\_TILE\_BASE(n)} y \textit{BG\_MAP\_BASE(n)}, serán los mismos que se especifiquen en las macros utilizadas para obtener la dirección de
%memoria donde escribir los datos de mapas y teselas. La macro \textit{BG\_TILE\_RAM(n)} se define como un puntero que apunta a la dirección de memoria \textit{0x06000000}
%más el desplazamiento (\textit{n} por \textit{0x4000}). Análogamente, la macro \textit{BG\_MAP\_RAM(n)} se define como un puntero que apunta a la dirección de memoria \textit{0x06000000} más el desplazamiento (\textit{n} por \textit{0x800}).\\
%
%Como ejemplo, se desea cargar en memoria la tesela \textit{pruebaTiles}, para ello se realiza: 
%
%\begin{verbatim}
%BGCTRL[0] = BG_32x32 | BG_COLOR_16 | BG_MAP_BASE(0) | BG_TILE_BASE(1);
%memcpy(BG_TILE_RAM(1),pruebaTiles,pruebaTilesLen);
%\end{verbatim}
%
%La primera línea especifica que  los datos del mapa están contenidos a partir de la dirección 0x0000 (\textit{BG\_MAP\_BASE(0)}), mientras que los datos de la tesela se encuentran a partir de la dirección 0x04000 (\textit{el múltiplo 1 de 16KB}), especificado en \textit{BG\_TILE\_BASE(1)}. La segunda línea muestra cómo utilizar la macro \textit{BG\_TILE\_RAM(1)}, con el mismo número empleado en \textit{BG\_TILE\_BASE(1)}. Como se puede observar, la función utilizada para escribir los datos de las teselas es la función \textit{memcpy}, empleada en apartados anteriores. Sin embargo, también se podría haber utilizado la función \textit{dmaCopy} o \textit{swiCopy} como ya se ha descrito en el capítulo anterior. Es importante diferenciar entre lo que es el desplazamiento en la memoria que se especifica mediante la macro \textit{BG\_TILE\_BASE(n)} y la dirección de memoria, especificada con la macro \textit{BG\_TILE\_RAM(n)}, donde se escribirán los datos. Los desplazamientos en memoria se especifican en el momento de la configuración del fondo, mientras que la dirección de memoria se utiliza para acceder desde el programa a la zona donde está.
